// Copyright 2021 Michael Rodler
// This file is part of evm2cpp.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

use ethereum_types::U256;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::TryFrom;
use std::fs::File;

use crate::analysis::*;
use crate::instructions::*;
use crate::sourcemap::SourceMap;

use anyhow::Context;

fn emit_header() -> &'static str {
    "// auto-generated by evm2cpp
    "
}

fn format_label(pc: usize) -> String {
    format!("pc_{:x}", pc)
}

fn emit_bytecode(bytecode: &[u8], variable_name: &str) -> String {
    let mut ret = format!("const eevm::Code {} = {{\n", variable_name);
    for inst_byte in bytecode.into_iter() {
        ret.push_str(&format!("{:#x},", *inst_byte));
    }
    ret += "};\n";
    ret
}

fn emit_bytecode_and_diassembly(
    bytecode: &[u8],
    codemeta: &CodeMeta,
    variable_name: &str,
) -> String {
    let mut ret = format!("const eevm::Code {} = {{\n", variable_name);
    for (pc, inst_byte) in bytecode.into_iter().enumerate() {
        ret.push_str(&format!("{:#04x},", *inst_byte));
        if codemeta.is_instruction(pc) {
            if let Some(i) = Instruction::from_u8(*inst_byte) {
                ret.push_str(&format!(" /* [{0}'{0:#x}] {1:?} */\n", pc, i));
            } else {
                ret.push_str(&format!(" /* [{0}'{0:#x}] INVALID' byte */\n", pc));
            }
        } else if codemeta.is_instruction(pc + 1) {
            ret.push_str("/* constant data */\n");
        }
    }
    ret += "};\n";
    ret
}

fn emit_jumptable(codemeta: &CodeMeta) -> String {
    let mut ret = String::from(
        "
static void* _JUMP_TABLE_ARR[] = {&&_evm_start,\n
    ",
    );
    for pc in 1..codemeta.len() {
        if codemeta.is_valid_jumpdest(pc) {
            ret.push_str(&format!("&&{},\n", format_label(pc)))
        } else {
            ret.push_str("&&__invld,\n")
        }
    }
    ret.push_str(
        "
};

goto _evm_start;

__invld:
    throw Exception(ET::illegalInstruction, \"EVM-level invalid jump target\");

#define JUMP(target) { \\
    uint64_t _jump_target = static_cast<uint64_t>(target); \\
    if (_jump_target < (std::size(_JUMP_TABLE_ARR))) { \\
        goto *_JUMP_TABLE_ARR[_jump_target]; \\
    } else { goto __invld; }}

_evm_start:
    ",
    );
    ret
}

fn format_constant(constant: U256, interned_globals: &mut BTreeMap<U256, String>) -> String {
    //if constant.bits() < 64 || constant < U256::from(std::u64::MAX) {
    //    format!("({:#x})n", constant)
    //} else {
    //    // the _u256 is a C++ constexpr, so there should be no runtime overhead...
    //    format!("({:#x}_u256)", constant)
    //}

    let last = interned_globals.len();
    if constant.bits() <= 32 {
        interned_globals
            .entry(constant)
            .or_insert(format!("c_{:x}", constant))
            .clone()
    } else {
        interned_globals
            .entry(constant)
            .or_insert(format!("g_{}", last))
            .clone()
    }
}

#[allow(dead_code)]
fn emit_invalid_inst() -> String {
    format!("throw Exception(ET::illegalInstruction, \"invalid jump target\");\n")
}

fn emit_explicit_invalid_inst_at(pc: usize, idx: usize) -> String {
    format!(
        "throw Exception(ET::illegalInstruction, \"INVALID instruction @ {:#x} (inst offset {})\");\n",
        pc, idx
    )
}

fn emit_invalid_inst_at(pc: usize, idx: usize, opbyte: u8) -> String {
    format!(
        "throw Exception(ET::illegalInstruction, \"invalid instruction @ {:#x} (inst offset {}; byte {:#x})\");\n",
        pc, idx, opbyte
    )
}

fn emit_jump(inst: &IInstruction, codemeta: &CodeMeta) -> String {
    let jump_dest = inst.operands.as_ref().unwrap()[0];
    match jump_dest {
        Operand::Constant((_, val)) => {
            if val.bits() <= 32 && codemeta.is_valid_jumpdest(val.as_u32() as usize) {
                format!("goto {};\n", format_label(val.as_usize()))
            } else {
                format!(
                    "throw Exception(ET::illegalInstruction, \"invalid jump target {:#x}\");\n",
                    val
                )
            }
        }
        Operand::StackPop(_) => "JUMP(ctxt->s.pop());\n".to_string(),
        Operand::InstructionRef((i, j)) => format!("JUMP(v_{}_{});\n", i, j),
        Operand::StackRef((i, j)) => format!("JUMP(s_{}_{});\n", i, j),
    }
}

fn emit_basic_block(
    bb: &BasicBlock,
    codemeta: &CodeMeta,
    interned_globals: &mut BTreeMap<U256, String>,
    sourcemap: Option<&SourceMap>,
) -> String {
    let mut r = format_label(bb.address);
    r += ":\n{ /* <============ */ \n";
    //else if let Some(valvec) = &inst.value {
    //                // if the inst has an associated value and is not ignoreable then we push a constant
    //                for val in valvec {
    //                    r += &emit_push_constant(*val);
    //                }
    //            }
    // iterate over non-ignoreable instructions
    //

    //r += &format!("/* {:?} */\n\n", bb);

    r += &format!("on_bb_start({});\n", bb.address);

    if let Some(sm) = sourcemap {
        if bb.instructions.len() > 0 {
            let inst = &bb.instructions[0];
            let line_ref = if inst.global_idx >= sm.len() {
                &sm[sm.len() - 1].line
            } else {
                &sm[inst.global_idx].line
            };
            let line_sanit = line_ref[0..std::cmp::min(line_ref.len(), 200)].to_string();
            let line_sanit = line_sanit.replace("*/", "*\\/");
            r += &format!(
                "#if 0\n/****** Source ******\n{}\n**************/\n#endif\n\n",
                line_sanit
            );
        }
    }

    let mut instructions_gen = Vec::<String>::with_capacity(bb.instructions.len());
    let mut stack_peeks = BTreeMap::<usize, BTreeSet<usize>>::new();

    let mut finalizer_emitted = false;
    let mut finalizer: String = "/* BB finalizer */\n".to_string();
    finalizer += &if bb.stack_sets.len() > 0 {
        let set_gen: Vec<String> = bb
            .stack_sets
            .iter()
            .map(|(&slot_idx, &operand)| match operand {
                Operand::StackPop(_) => panic!(
                    "Unexpected operand {:?} in BasicBlock.stack_sets slot {}",
                    operand, slot_idx
                ),
                Operand::Constant((_, val)) => {
                    format!(
                        "ctxt->s.set({}, {});\n",
                        slot_idx,
                        format_constant(val, interned_globals)
                    )
                }
                Operand::StackRef((inst_idx, stack_slot)) => {
                    stack_peeks.entry(inst_idx).or_default().insert(stack_slot);
                    format!(
                        "ctxt->s.set({}, s_{}_{});\n",
                        slot_idx, inst_idx, stack_slot
                    )
                }
                Operand::InstructionRef((inst_idx, stack_slot)) => {
                    format!(
                        "ctxt->s.set({}, v_{}_{});\n",
                        slot_idx, inst_idx, stack_slot
                    )
                }
            })
            .collect();
        set_gen.as_slice().join("\n")
    } else {
        "/* no stack sets */\n".to_string()
    };
    finalizer += &if bb.pops_at_end > 0 {
        format!("ctxt->s.pop_drop_n({});\n", bb.pops_at_end)
    } else {
        "/* no pops at end */\n".to_string()
    };
    if bb.returns.len() > 0 {
        for (i, o) in bb.returns.iter().rev().enumerate() {
            finalizer += &format!("/* BB return {} {:?}*/\n", i, *o);
            finalizer += &match *o {
                Operand::Constant((_, val)) => format!(
                    "ctxt->s.push({});\n",
                    format_constant(val, interned_globals)
                ),
                Operand::StackPop(_) => panic!("BB returns StackPop - This shouldn't happen?"),
                Operand::InstructionRef((i, j)) => format!("ctxt->s.push(v_{}_{});\n", i, j),
                Operand::StackRef((i, j)) => {
                    stack_peeks.entry(i).or_default().insert(j);
                    format!("ctxt->s.push(s_{}_{});\n", i, j)
                }
            }
        }
    } else {
        finalizer += "/* no BB returns */\n";
    }

    for (idx, inst) in bb.instructions.iter().enumerate() {
        let mut r = String::new();
        match inst.opcode {
            Ok(op) => {
                // print out the instructions
                r += &format!("/* {:?} */\n", op);
                //r += &format!("/* {:?} */\n", inst);
                // do nothing if it is ignorable
                //r += "\n";
                let iinfo = op.info();
                let mut operand_gen = Vec::<String>::with_capacity(iinfo.args);
                if let Some(operands) = &inst.operands {
                    for (o_idx, o) in operands.iter().enumerate() {
                        r += &format!("/* op_{} = {:?} */\n", o_idx, *o);
                        match *o {
                            Operand::InstructionRef((other_idx, offset)) => {
                                operand_gen.push(format!("v_{}_{}", other_idx, offset));
                            }
                            Operand::Constant((_, value)) => {
                                operand_gen.push(format_constant(value, interned_globals));
                            }
                            Operand::StackPop(_) => {
                                operand_gen.push("ctxt->s.pop()".to_string());
                            }
                            Operand::StackRef((other_idx, offset)) => {
                                operand_gen.push(format!("s_{}_{}", other_idx, offset));
                                let m = stack_peeks.entry(other_idx).or_default();
                                m.insert(offset);
                            }
                        }
                    }
                }
                if let Some(val) = &inst.value {
                    r += &format!("/* val = {:?} */\n", *val);
                }
                if inst.ignoreable {
                    instructions_gen.push(r);
                    continue;
                }

                match op {
                    Instruction::SGT
                    | Instruction::GT
                    | Instruction::SLT
                    | Instruction::LT
                    | Instruction::EQ => {
                        if let Some(operands) = &inst.operands {
                            let mut inst_name = inst.get_name().clone();
                            inst_name.make_ascii_uppercase();
                            let mut trace_code =
                                format!("TRACE_COMP(eevm::Opcode::{}, ", inst_name);
                            let mut has_const = false;
                            for (o_idx, o) in operands.iter().enumerate() {
                                match *o {
                                    Operand::Constant(_) => {
                                        has_const = true;
                                        break;
                                    }
                                    _ => {
                                        trace_code += &format!("{}, ", operand_gen[o_idx]);
                                    }
                                }
                            }

                            // if one of the two is a constant, then they are added to dictionary,
                            // so we do not need to emit compare tracing code.
                            if !has_const {
                                r += &trace_code[0..trace_code.len() - 2];
                                r += ");\n";
                            }
                        }
                        // what
                    }
                    _ => {}
                }

                // else emit code
                if op.is_jump() {
                    if op == Instruction::JUMP {
                        finalizer_emitted = true;
                        r += &format!("{}\n{}", finalizer, emit_jump(inst, codemeta));
                    } else if op == Instruction::JUMPI {
                        r += &format!(
                            "if ( {} ) {{ \n {} \n {} \n }}",
                            operand_gen[1],
                            finalizer,
                            emit_jump(inst, codemeta),
                        );
                    } else {
                        panic!("codegen not implemented: {:?}", op);
                    }
                } else if op.dup_position().is_some() {
                    let operands = inst.operands.as_ref().unwrap();
                    match operands[0] {
                        Operand::StackRef(_) | Operand::InstructionRef(_) => {
                            r += &format!("ctxt->s.push({});\n", operand_gen[0]);
                        }
                        _ => panic!(
                            "codegen of dup of operand {:?} not implemented",
                            operands[0]
                        ),
                    }
                } else if op.swap_position().is_some() {
                    // TODO: something is severely wrong with the swap handling, especially when
                    // swapping values that are outside of the current BB's "stack frame", i.e.,
                    // during code-gen we really need to operate on the "real" EVM stack instead of
                    // using the generated variable names. We should be able to summarize the stack
                    // effects at the very end of the BB, I guess.
                    //
                    // check the basic block `pc_76` for a problematic BB
                    let operands = inst.operands.as_ref().unwrap();
                    match (operands[0], operands[1]) {
                        (Operand::StackRef(_), Operand::StackRef((_, idx))) => {
                            r += &format!("ctxt->s.set({}, {});\n", idx, operand_gen[0]);
                            r += &format!("ctxt->s.set(0, {});\n", operand_gen[1]);
                        }
                        (
                            Operand::Constant((_, val)),
                            Operand::StackRef((other_idx, stack_offset)),
                        ) => {
                            let c = format_constant(val, interned_globals);
                            r += &format!("ctxt->s.set({}, {});\n", stack_offset, c);
                            stack_peeks.entry(other_idx).and_modify(|m| {
                                m.remove(&stack_offset);
                            });
                        }
                        (Operand::InstructionRef(_), Operand::StackRef((_, stack_slot))) => {
                            r += &format!("ctxt->s.set({}, {});\n", stack_slot, operand_gen[0]);
                        }
                        _ => {
                            panic!(
                            "this should never occur?!? operand[0] = {:?} and operand[1] = {:?}",
                            operands[0], operands[1]
                        );
                        }
                    }
                } else {
                    let ret_count = iinfo.ret;
                    let mut output_vars = Vec::<String>::with_capacity(ret_count);
                    if ret_count == 1 {
                        // we special case operations with only one return value. These are returned via
                        // the C++ return type. This allows us to implement at least some of those
                        // operations as constexpr functions in C++ -> might give us a little bit of
                        // additional performance.
                        r += &format!("const uint256_t v_{}_0 = ", idx);
                    } else {
                        for i in 0..ret_count {
                            let v = format!("v_{}_{}", idx, i);
                            r += &format!("uint256_t {};\n", v);
                            output_vars.push(format!("&{}", v));
                        }
                    }
                    r += &format!("{}_v(", inst.get_name(),);
                    r += &operand_gen.into_iter().chain(output_vars.into_iter()).fold(
                        "".to_string(),
                        |acc, x| {
                            if acc.is_empty() {
                                x
                            } else {
                                format!("{}, {}", acc, x)
                            }
                        },
                    );
                    r += ");\n";
                }

                if op.stops() {
                    r += "goto exit_label;\n";
                }

                match op {
                    Instruction::CALL
                    | Instruction::STATICCALL
                    | Instruction::DELEGATECALL
                    | Instruction::CALLCODE
                    | Instruction::CREATE
                    | Instruction::CREATE2 => {
                        r += "if (ctxt->error) goto exit_label;\n";
                    }
                    _ => {}
                }

                r += "\n";
            }
            Err(opbyte) => {
                // invalid opcode
                r += &emit_invalid_inst_at(bb.address, idx, opbyte);
            }
        }

        instructions_gen.push(r);
    }

    for (i, s) in instructions_gen.into_iter().enumerate() {
        if let Some(offsets) = stack_peeks.get(&i) {
            for x in offsets {
                r += &format!("const uint256_t s_{}_{} = ctxt->s.peek({});\n", i, x, x);
            }
        }

        r += &s;
        r += "\n";
    }

    if let Some(sm) = sourcemap {
        if !bb.instructions.is_empty() {
            let inst = &bb.instructions[bb.instructions.len() - 1];
            let line_ref = if inst.global_idx >= sm.len() {
                &sm[sm.len() - 1].line
            } else {
                &sm[inst.global_idx].line
            };
            let line_sanit = line_ref[0..std::cmp::min(line_ref.len(), 200)].to_string();
            let line_sanit = line_sanit.replace("*/", "*\\/");
            r += &format!(
                "#if 0\n/****** Source ******\n{}\n**************/\n#endif\n\n",
                line_sanit
            );
        }
    }

    if !finalizer_emitted {
        r += &finalizer;
    }

    r += "}";

    r
}

//fn translate_bb

pub fn translate_to_c(
    eevm_path: &std::path::Path,
    contract_id: &str,
    bytecode: Vec<u8>,
    constructor_bytecode: Option<Vec<u8>>,
    sourcemap: Option<SourceMap>,
    run_clang_format: bool,
) -> anyhow::Result<()> {
    let mut evm_program = Program::new(&bytecode);

    // run the optimizer
    evm_program.optimize();

    let s = format!("contracts/{}.cpp", contract_id);
    let file_path = eevm_path.join(s);
    let s = format!("include/eEVM/evm2cpp/contracts/{}.h", contract_id);
    let h_file_path = eevm_path.join(s);
    let all_h_file_path = eevm_path.join("include/eEVM/evm2cpp/contracts.h");

    let s = format!("contracts/{}.bb_list", contract_id);
    let bb_list_file_path = eevm_path.join(s);

    // create a new scope to auto-close file at end
    {
        // first we get the basic blocks and jump targets
        {
            let bb_addresses: Vec<String> = evm_program
                .basic_blocks
                .iter()
                .map(|bb| format!("{:#x}", bb.address))
                .collect();
            let mut file = File::create(&bb_list_file_path)
                .with_context(|| format!("failed to create file at {:?}", bb_list_file_path))?;
            file.write_all(bb_addresses.join("\n").as_bytes())?;
            file.write_all(b"\n")?;
        }

        let mut file = File::create(&file_path)
            .with_context(|| format!("failed to create file at {:?}", file_path))?;
        let mut h_file = File::create(&h_file_path)
            .with_context(|| format!("failed to create file at {:?}", h_file_path))?;

        file.write_all(emit_header().as_bytes())?;
        h_file.write_all(emit_header().as_bytes())?;

        h_file.write_all(
            format!(
                "
#pragma once

#include \"eEVM/SpecializedProcessorFactory.h\"

using namespace intx;

namespace eevm
{{
  class EVM2CPP_{0} : public SpecializedProcessor
  {{
    using SpecializedProcessor::SpecializedProcessor;

    private:
      static const std::string _contract_name;
      static const DerivedRegister<EVM2CPP_{0}> reg;

    public:
      void dispatch() override;
      const Code& bytecode() override;
      const Code& constructor_bytecode() override;
      const Code& constructor_args() override;
      const std::string& name() override;

#ifdef EVM2CPP_HAS_DUPLICATE_METHOD
      std::unique_ptr<SpecializedProcessor> duplicate() override {{
         return std::make_unique<EVM2CPP_{0}>();
      }};
#endif
  }};
}}

",
                contract_id
            )
            .as_bytes(),
        )?;

        file.write_all(
            format!(
                "
// associated header file
#include \"eEVM/evm2cpp/contracts/{}.h\"

// additional tracing code
#include \"eEVM/fuzz/tracecomp.hpp\"

",
                contract_id
            )
            .as_bytes(),
        )?;

        file.write_all(
            "
// this is generated code and we might have emitted some variables/labels that are not actually used anymore
#pragma GCC diagnostic ignored \"-Wunused-variable\"
#pragma GCC diagnostic ignored \"-Wunused-label\"\n\n"
                .as_bytes(),
        )?;

        file.write_all(
            emit_bytecode_and_diassembly(&bytecode, &evm_program.meta, "_contract_bytecode")
                .as_bytes(),
        )?;

        file.write_all(
            format!(
                "
const eevm::Code& eevm::EVM2CPP_{0}::bytecode() {{
    return _contract_bytecode;
}}

const std::string eevm::EVM2CPP_{0}::_contract_name = \"{0}\";
[[maybe_unused]] const eevm::DerivedRegister<eevm::EVM2CPP_{0}> eevm::EVM2CPP_{0}::reg{{}};
const std::string& eevm::EVM2CPP_{0}::name() {{
    return _contract_name;
}}

// interned globals

",
                contract_id
            )
            .as_bytes(),
        )?;
        let code_meta = &evm_program.meta;
        let mut globals: BTreeMap<U256, String> = BTreeMap::new();

        let mut dispatch_code = format!(
            "

// code
void eevm::EVM2CPP_{}::dispatch() {{
    ",
            contract_id
        );
        dispatch_code += &emit_jumptable(code_meta);

        for bb in evm_program.basic_blocks.iter() {
            dispatch_code += &emit_basic_block(bb, code_meta, &mut globals, sourcemap.as_ref());
        }
        dispatch_code += "exit_label:\n  return;\n}\n\n";

        // now we write the interned globals
        let global_vars: Vec<String> = globals
            .iter()
            .map(|(constant, global_var)| {
                format!("constexpr uint256_t {} = {:#x}_u256;", global_var, constant)
            })
            .collect();
        file.write_all(global_vars.join("\n").as_bytes())?;

        file.write_all(dispatch_code.as_bytes())?;

        if let Some(constructor_bytecode) = constructor_bytecode {
            file.write_all(
                emit_bytecode(&constructor_bytecode, "_constructor_bytecode").as_bytes(),
            )?;
        } else {
            file.write_all(
                "
const eevm::Code _constructor_bytecode = {};
            "
                .as_bytes(),
            )?;
        }

        file.write_all(
            format!(
                "

const eevm::Code& eevm::EVM2CPP_{0}::constructor_bytecode() {{
    return _constructor_bytecode;
}}

// TODO: update this if you want constructor arguments.
const eevm::Code _constructor_args = {{}};

const eevm::Code& eevm::EVM2CPP_{0}::constructor_args() {{
    return _constructor_args;
}}
",
                contract_id
            )
            .as_bytes(),
        )?;

        use std::fs::OpenOptions;
        use std::io::prelude::*;

        let mut all_h_file = OpenOptions::new()
            .write(true)
            .append(true)
            .open(&all_h_file_path)
            .with_context(|| {
                format!("failed to open file at {:?} for appending", all_h_file_path)
            })?;
        let contract_include = format!(
            "#include \"{}\"\n",
            h_file_path
                .strip_prefix(eevm_path)
                .unwrap()
                .strip_prefix("include/")
                .unwrap()
                .to_str()
                .unwrap()
        );
        all_h_file.write_all(contract_include.as_bytes())?;

        // finally write a dictionary file for the contract
        let s = format!("fuzz/dict/{}.dict", contract_id);
        let dict_file_path = eevm_path.join(s);
        let mut dict_file = File::create(dict_file_path.clone())
            .with_context(|| format!("failed to create dictionary file at {:?}", dict_file_path))?;
        for (const_val, _) in globals.into_iter() {
            // filter 0 and some unintersting values, such as bitmasks, -1 (for various bit widths)
            if const_val.is_zero()
                || if const_val.bits() <= 64 {
                    evm_program
                        .meta
                        .is_valid_jumpdest(usize::try_from(const_val.as_u64()).unwrap())
                } else {
                    false
                }
            {
                continue;
            }

            let mut bytes = [0u8; 32];
            const_val.to_big_endian(&mut bytes);

            // check if the bytes are actually interesting
            if bytes.iter().any(|&b| b != 0 && b != 1 && b != 0xff) {
                let mut s = String::new();
                for b in bytes.iter().skip_while(|&&b| b == 0) {
                    s.push_str(&format!("\\x{:02X}", b));
                }
                let entry = format!("\"{}\"\n", s);
                dict_file.write_all(entry.as_bytes())?;
            }
        }
    }

    if run_clang_format {
        const CLANG_FORMATS_TRY: [&str; 5] = [
            "clang-format",
            "clang-format-13",
            "clang-format-12",
            "clang-format-11",
            "clang-format-10",
        ];
        // try to launch all kinds of clang-format, whatever is installed really
        'outter: for proc in &CLANG_FORMATS_TRY {
            for f in &[&file_path, &h_file_path, &all_h_file_path] {
                // files are closed, we run clang-format if possible
                match std::process::Command::new(proc)
                    .arg("--sort-includes")
                    .arg("-i")
                    .arg(&f)
                    .spawn()
                {
                    Ok(_) => {}
                    Err(e) => {
                        match e.kind() {
                            std::io::ErrorKind::NotFound => {
                                if proc == CLANG_FORMATS_TRY.last().unwrap() {
                                    println!("WARNING: Could not launch clang-format(-1[0-3])",);
                                }
                                continue 'outter;
                            }
                            _ => println!(
                                "WARNING: failed to spawn {} (error: {} [kind={:?}])",
                                proc,
                                e,
                                e.kind()
                            ),
                        };
                    }
                }
            }
            break;
        }
    }

    anyhow::Result::Ok(())
}
